server:
  port: 8080 # En Docker, el puerto 8080 del contenedor se mapea al 8080 del host

spring:
  application:
    name: gateway

  security:
    oauth2:
      resourceserver:
        jwt:
          # En Docker usamos JWKS explícito (no issuer-uri) para evitar problemas de hostname
          # Apunta al JWKS del Keycloak dentro del entorno dockerizado
          jwk-set-uri: ${SPRING_SECURITY_OAUTH2_RESOURCESERVER_JWT_JWK_SET_URI}

#  cloud:
#    gateway:
#      server:
#        webflux:
#          default-filters:
#            # Añadiremos filtros propios en el siguiente paso
#            - RemoveRequestHeader=Cookie
#          routes:
#            - id: users
#              uri: ${GATEWAY_USERS_URI}
#              predicates:
#                - Path=${GATEWAY_USERS_PATH}
#                - Path=${GATEWAY_INSTRUMENTS_PATH}
#
#            - id: events
#              uri: ${GATEWAY_EVENTS_URI}
#              predicates:
#                - Path=${GATEWAY_EVENTS_PATH}
#
#            - id: scores
#              uri: ${GATEWAY_SCORES_URI}
#              predicates:
#                - Path=${GATEWAY_SCORES_PATH}
#
#            - id: surveys
#              uri: ${GATEWAY_SURVEYS_URI}
#              predicates:
#                - Path=${GATEWAY_SURVEYS_PATH}

management:
  endpoints:
    web:
      exposure:
        include: health,info

logging:
  level:
    root: INFO
    org.springframework.cloud.gateway: TRACE
    com.tfm.bandas.gateway: DEBUG

gateway:
  instruments:
    path: ${GATEWAY_INSTRUMENTS_PATH}
  roles:
    path: ${GATEWAY_ROLES_PATH}
  users:
    uri: ${GATEWAY_USERS_URI}
    path: ${GATEWAY_USERS_PATH}
  events:
    uri: ${GATEWAY_EVENTS_URI}
    path: ${GATEWAY_EVENTS_PATH}
  scores:
    uri: ${GATEWAY_SCORES_URI}
    path: ${GATEWAY_SCORES_PATH}
  surveys:
    uri: ${GATEWAY_SURVEYS_URI}
    path: ${GATEWAY_SURVEYS_PATH}
